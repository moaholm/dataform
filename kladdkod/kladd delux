SELECT 
    DATE(o.invoiceDate) AS period,
    SUM(CAST(oi.quantity AS FLOAT64)) AS total_products_sold,
    SUM(oi.subtotal) AS total_revenue,
    SUM(oi.subtotal - (oi.quantity * p.recommendedRetailPrice)) AS total_profit,
    COUNT(DISTINCT o.customerID) AS unique_customers
FROM 
    `clean.orders` o
JOIN 
    `clean.orderItems` oi ON o.orderID = oi.orderID
JOIN 
    `clean.products` p ON oi.productID = p.productId
GROUP BY 
    DATE(o.invoiceDate)
ORDER BY 
    period;

----- F칬rsta Mart tabellen. Pausar f칬r att jag beh칬ver g칬ra rent mitt clean lager. ----

1. F칬rs칛ljningssammanfattning per tidsperiod
Ett faktatabell (fact table) med data som summerar f칬rs칛ljningen 칬ver tid. Tidsdimensionen kan vara p친 daglig, veckovis, m친nadsvis eller 친rsvis niv친.

Kolumner:

Datum (date, m친nad, 친r, kvartal)
Totalt antal s친lda produkter
Total f칬rs칛ljning (subtotal i Order_Items)
Totala vinsten (Total f칬rs칛ljning - Total ink칬pskostnad baserat p친 purchasePrice)
Antal unika kunder
Syfte:

Analysera f칬rs칛ljningstrender 칬ver tid, exempelvis b칛sta m친nader, veckodagar, eller perioder.

2. Produktf칬rs칛ljningsanalys
Ett mart-lager f칬r att sp친ra vilka produkter som s칛ljer b칛st.

Kolumner:

Produkt-ID (productId)
Produktnamn
Kategori (categoryName)
S친lda enheter (summering av quantity)
Totala int칛kter (summering av subtotal)
Totala ink칬pskostnader (summering av quantity * purchasePrice)
Vinsten (Totala int칛kter - Totala ink칬pskostnader)
Syfte:

Identifiera stors칛ljare, l친gpresterande produkter och kategorier med h칬g vinstmarginal.

3. Kundanalys
Ett mart-lager f칬r att analysera kunder och deras k칬pbeteende.

Kolumner:

Kund-ID (customerID)
Kundnamn (f칬r- och efternamn)
Totalt antal k칬p (antal orderNumber)
Totalt spenderat belopp (summering av totalAmount fr친n Orders)
Snittk칬p per order (TotalAmount / antal ordrar)
Postnummer (zipCode)
Syfte:

Segmentera kunder baserat p친 k칬pvanor, identifiera h칬gv칛rdeskunder och geografiska omr친den som k칬per mest.

4. F칬rs칛ljning per geografisk plats
Ett mart-lager f칬r att analysera f칬rs칛ljning baserat p친 kundernas geografiska plats.

Kolumner:

Stad (city)
Postnummer (zipCode)
Antal s친lda enheter (summering av quantity)
Totala int칛kter (summering av subtotal i Order_Items)
Antal kunder (antal unika customerID)
Syfte:

Identifiera omr친den med h칬gst f칬rs칛ljning och analysera regionala f칬rs칛ljningstrender.

5. Orderanalys
Ett mart-lager f칬r detaljerad orderanalys.

Kolumner:

Ordernummer (orderNumber)
Orderdatum (orderDate)
Kund-ID (customerID)
Totala int칛kter per order (totalAmount fr친n Orders)
Antal produkter i ordern (summering av quantity fr친n Order_Items)
Genomsnittligt pris per produkt (totalAmount / antal produkter)
Syfte:

Analysera orderstorlekar, genomsnittligt orderv칛rde och toppkunder baserat p친 ordervolym.

6. M친tt och KPI:er
Dessa mart-tabeller kan anv칛ndas f칬r att ber칛kna och visualisera nyckeltal:

Total f칬rs칛ljning: Summa av subtotal i Order_Items.
Genomsnittligt orderv칛rde: TotalAmount / antal ordrar.
Vinstmarginal: (Totala int칛kter - Totala ink칬pskostnader) / Totala int칛kter.
Retentionsgrad: Andel 친terkommande kunder (kunder med fler 칛n 1 order).
Teknik att implementera
ETL-process (Extract, Transform, Load):
Extrahera data fr친n din ursprungsdatabas (exempelvis Orders, Order_Items, Products, och Customers).
Transformera data till aggregerade m친tt.
Ladda in den till din datamart.
Visualisering:
Anv칛nd verktyg som Power BI, Tableau, eller Excel f칬r att bygga dashboards och rapporter.
Vill du ha hj칛lp med att skapa SQL-fr친gor f칬r n친gon av dessa tabeller? 游땕






Du sade:
Ja, hur ser sql-fr친gorna ut till dessa? :)
ChatGPT sade:

ChatGPT
H칛r kommer SQL-fr친gorna f칬r att skapa och fylla tabeller f칬r varje del av ditt mart-lager. Dessa fr친gor 칛r anpassade f칬r ditt schema och kan anv칛ndas i exempelvis MySQL eller PostgreSQL (med sm친 justeringar om n칬dv칛ndigt).

1. F칬rs칛ljningssammanfattning per tidsperiod
-- Skapa tabell f칬r f칬rs칛ljningssammanfattning
CREATE TABLE SalesSummary (
    period DATE,
    total_products_sold INT,
    total_revenue DECIMAL(10, 2),
    total_profit DECIMAL(10, 2),
    unique_customers INT
);

-- Fyll tabellen med data
INSERT INTO SalesSummary (period, total_products_sold, total_revenue, total_profit, unique_customers)
SELECT 
    DATE(o.orderDate) AS period,
    SUM(oi.quantity) AS total_products_sold,
    SUM(oi.subtotal) AS total_revenue,
    SUM(oi.subtotal - (oi.quantity * p.purchasePrice)) AS total_profit,
    COUNT(DISTINCT o.customerID) AS unique_customers
FROM 
    Orders o
JOIN 
    Order_Items oi ON o.orderNumber = oi.orderNumber
JOIN 
    Products p ON oi.productId = p.productId
GROUP BY 
    DATE(o.orderDate)
ORDER BY 
    period;
2. Produktf칬rs칛ljningsanalys
-- Skapa tabell f칬r produktf칬rs칛ljning
CREATE TABLE ProductSales (
    productId INT,
    productName VARCHAR(255),
    categoryName VARCHAR(255),
    total_units_sold INT,
    total_revenue DECIMAL(10, 2),
    total_cost DECIMAL(10, 2),
    total_profit DECIMAL(10, 2)
);

-- Fyll tabellen med data
INSERT INTO ProductSales (productId, productName, categoryName, total_units_sold, total_revenue, total_cost, total_profit)
SELECT 
    p.productId,
    p.productName,
    p.categoryName,
    SUM(oi.quantity) AS total_units_sold,
    SUM(oi.subtotal) AS total_revenue,
    SUM(oi.quantity * p.purchasePrice) AS total_cost,
    SUM(oi.subtotal - (oi.quantity * p.purchasePrice)) AS total_profit
FROM 
    Products p
JOIN 
    Order_Items oi ON p.productId = oi.productId
GROUP BY 
    p.productId, p.productName, p.categoryName
ORDER BY 
    total_revenue DESC;
3. Kundanalys
-- Skapa tabell f칬r kundanalys
CREATE TABLE CustomerAnalysis (
    customerId INT,
    customerName VARCHAR(255),
    total_orders INT,
    total_spent DECIMAL(10, 2),
    average_order_value DECIMAL(10, 2),
    zipCode VARCHAR(20)
);

-- Fyll tabellen med data
INSERT INTO CustomerAnalysis (customerId, customerName, total_orders, total_spent, average_order_value, zipCode)
SELECT 
    c.customerID,
    CONCAT(c.firstName, ' ', c.lastName) AS customerName,
    COUNT(o.orderNumber) AS total_orders,
    SUM(o.totalAmount) AS total_spent,
    AVG(o.totalAmount) AS average_order_value,
    c.zipCode
FROM 
    Customers c
JOIN 
    Orders o ON c.customerID = o.customerID
GROUP BY 
    c.customerID, c.firstName, c.lastName, c.zipCode
ORDER BY 
    total_spent DESC;
4. F칬rs칛ljning per geografisk plats
-- Skapa tabell f칬r f칬rs칛ljning per geografisk plats
CREATE TABLE GeographicSales (
    city VARCHAR(255),
    zipCode VARCHAR(20),
    total_units_sold INT,
    total_revenue DECIMAL(10, 2),
    total_customers INT
);

-- Fyll tabellen med data
INSERT INTO GeographicSales (city, zipCode, total_units_sold, total_revenue, total_customers)
SELECT 
    c.city,
    c.zipCode,
    SUM(oi.quantity) AS total_units_sold,
    SUM(oi.subtotal) AS total_revenue,
    COUNT(DISTINCT c.customerID) AS total_customers
FROM 
    Customers c
JOIN 
    Orders o ON c.customerID = o.customerID
JOIN 
    Order_Items oi ON o.orderNumber = oi.orderNumber
GROUP BY 
    c.city, c.zipCode
ORDER BY 
    total_revenue DESC;
5. Orderanalys
-- Skapa tabell f칬r orderanalys
CREATE TABLE OrderAnalysis (
    orderNumber INT,
    orderDate DATE,
    customerId INT,
    total_revenue DECIMAL(10, 2),
    total_products INT,
    average_price_per_product DECIMAL(10, 2)
);

-- Fyll tabellen med data
INSERT INTO OrderAnalysis (orderNumber, orderDate, customerId, total_revenue, total_products, average_price_per_product)
SELECT 
    o.orderNumber,
    o.orderDate,
    o.customerID,
    o.totalAmount AS total_revenue,
    SUM(oi.quantity) AS total_products,
    AVG(oi.unitPrice) AS average_price_per_product
FROM 
    Orders o
JOIN 
    Order_Items oi ON o.orderNumber = oi.orderNumber
GROUP BY 
    o.orderNumber, o.orderDate, o.customerID, o.totalAmount
ORDER BY 
    o.orderDate;
6. KPI:er och nyckeltal
Vill du bara h칛mta nyckeltal och inte skapa nya tabeller kan du anv칛nda aggregerande fr친gor direkt i rapporteringsverktyg:

Total f칬rs칛ljning:

SELECT SUM(subtotal) AS total_sales FROM Order_Items;
Genomsnittligt orderv칛rde:

SELECT AVG(totalAmount) AS avg_order_value FROM Orders;
Vinstmarginal:

SELECT 
    (SUM(oi.subtotal) - SUM(oi.quantity * p.purchasePrice)) / SUM(oi.subtotal) AS profit_margin
FROM 
    Order_Items oi
JOIN 
    Products p ON oi.productId = p.productId;
Andel 친terkommande kunder:

SELECT 
    (COUNT(DISTINCT CASE WHEN order_count > 1 THEN customerID END) * 100.0 / COUNT(DISTINCT customerID)) AS repeat_customer_rate
FROM (
    SELECT customerID, COUNT(orderNumber) AS order_count
    FROM Orders
    GROUP BY customerID
) subquery;